## 一.用于定义访问权限的关键字（访问控制）
### 1. private私有的
- 是一个权限修饰符，可修饰成员变量和成员方法，内部类
- 被private修饰后的成员只能在本类中访问
- 定义类的时候，用private修饰成员变量，需要提供getter和setter方法，这样做可以提高数据的安全性
### 2. protected受保护的
- 是一个权限修饰符，对于类的调用者来说，protect修饰的字段和方法不能被访问的
- 对于子类和和同一个包的其它类，protect修饰的字段和方法是可以被访问的

### 3. public公共的
- 是一个权限修饰符，修饰类，方法，字段
- 被public修饰的类，方法，字段可以在任何类或者包中访问
### 4. 总结
- private：类内部可以访问呢，类外部不可访问
- default：类内部可以访问，同一个包中的类也可以访问
- protected：类内部可以访问，子类和同一包中的类可以访问
- public：类内部和类的调用者都可以访问
### 5. 使用场景
> 我们希望类要尽量做到”封装“，也就是说隐藏内部的实现细节，只要暴露出必要的信息给类的调用者。因此在使用的时候应该尽可能的使用比较严格的访问权限，例如一个方法可以使用private就不要使用public
## 二.用于定义类，函数，变量修饰符的关键字

###    1. abstract声明抽象
- abstract可以修饰类，方法
- abstract修饰的类可以扩展子类但不可以实例化
- abstract 方法不在声明它的类中出现（也就是没有方法体），但必须在某个子类中重写
- 含有abstract方法的类本就是抽象类，必须用abstract 修饰

###  2. final

- final关键字可用来修饰类，方法，变量，分别由不同的意义
- 修饰类：表示不可继承（没有子类）-final类中的所有成员方法会被隐式的指定为final方法
- 修饰方法：表示在子类中不可重写（**原因**：1. 把方法锁定防止任何继承类修改它的含义2. 效率）
    - 注意：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法。因此，此时可以在子类中定义相同的方法名和参数。==不再产生重写与final的矛盾，而是在子类中重新定义了新的方法==
- 修饰变量：表示常量，只能被赋值一次，复制后不再改变
    - 当final修饰基本数据类型时，表示该结女数据类型的值一旦被初始化，不可再修改
    - 当final修饰引用类型时，在其初始化虎不可指向其它对象了，单引用所指向的对象内是可以发生变化的（因为引用的值是一个地址，final要求求，也就是地址的值不发生改变）
    - final修饰一个类成员变量（属性），==必须要显示初始化==（局部变量只需保证在使用前被赋值即可）。这里有两种初始化方式，
        - 一种是在变量声明的时候初始化；
        - 第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。

### 3. static
###### 1. static代表着什么
- Java中不存在全局变量，但是我们可以==通过static来实现一个“伪全局”的概念，==　在Java中static代表“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以修饰代码块
- ==JVM在加载类的时候，若该类存在static修饰的成员变量和方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，那么JVM就可以很方便的访问它们==（只要这个类被加载，Java休尼吉就能根据类目在运行时数据区的方法区内找到它们
- 同时被static修饰的成员变量和成员方法时独立于该类的，==他不依赖于某个特定类的实例==，也就是说它被该类的所有实例共享。所有实例的引用指向同一个地方，==任何实例对其的修改都会导致其它实例的变化==
###### 2. static的使用
- **static变量**
    - static修饰的变量我们称之为静态变量
    - 没有static修饰的变量称为实例变量
    - 区别：
        - **静态变量：**　是随着类加载时被完成初始化的，在内存中只有一个，且JVM只会为它分配一次内存，同时类的所有实例共享静态变量，可以通过类名访问它。
        - **实例变量：**是伴随着实例的，欸创建一个实例就会禅城实例变量，于该实例同生共死
    - 使用场景：对象之间共享数据，方便访问
- **static方法**
    - static方法一般称为静态方法，由于静态方法不依赖任何对象就可以进行访问，既然没有对象，==就谈不上this。==
    - 因为不依赖对象，所以在静态方法中==不可访问非静态的成员变量和方法==，因为非静态成员变量和方法都必须依赖具体对象才能被调用
    - 但是，虽然静态方法不可访问非静态的成员方法和变量，但在非静态成员方法中是可以访问静态成员方法和变量的
    - **总结**：
        - 静态方法只可以调用其它的静态方法
        - 静态方法只可以访问静态数据
        - 静态方法不可用任何方式引用this和super
    - 使用场景：==如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static==　我们最常见的static方法就是main方法，至于为什么main方法必须是是他提出的－－因为在程序执行main方法的时候没有创建任何的实例对象，只能通过类名来访问
    - 注意：==即使没有显示地声明为static，类的构造器实际上也是静态方法。==
- **static代码块**
    - static代码块可以置于类中任何地方，类中可以有多个代码块。
    - ==在类被初次加载的时候，会按照static代码块的顺序来执行每个代码块，并且只执行一次==
    - 一位只会在类加载的时候执行一次，所以可以用来优化程序性能
    - 多把只需要进行一次的初始化操作放在static代码块中进行
- **static关键字误区**
    - static关键字会改变类中成员的访问权限吗？
        - Java中是static关键字不会影响成员的作用域，可以影响作用域的只有 private、public、protected
    - 能通过this访问静态成员变量吗？ 
        - 静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）
    - static能作用域局部变量吗？
        - Java中static不允许来修饰局部变量（没有为什么，规定而已）
    - static和final一块用表示什么？（两个关键字的特点结合回答即可）
        - 用来修饰成员变量和成员方法，可简单理解为“全局常量”
        - 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。
        - 对于方法，表示不可覆盖，并且可以通过类名直接访问。
- **代码执行过程**
    - 执行开始，先寻找main方法，因为main方法是程序的入口
     - 在执行main方法前必须先加载main方法所在的类
    - 在加载main方法所在类时，若其继承于父类，此时就会转去先加载父类
    - 加载父类时，若存在static代码块，就static代码块
    - 父类加载完继续加载子类，若存在静态代码库便加载静态代码块
    - 加载完所有的类，执行main方法
    - main方法ｎｅｗ子类对象，会先调用父类的构造代码块，然后再调用自身的构造代码块
        - ==静态代码块内容先执行，接着执行父类非静态代码块和构造方法，然后执行子类非静态代码块和构造方法。==
- **注意：**==子类的构造方法，不管是否参数，它都会先去寻找父类的不带参数的构造方法==。如果父类没有不带参数的构造方法，那么子类必须用supper关键子来调用父类带参数的构造方法，否则编译不能通过。

 
#### 4. synchronized（见多线程）
## 三.用于定义类和类之间关系的关键字
### 1. extends
- 相关概念
    - 通过extends关键字继承一个已有的类，内继承的类称为父类（超类，基类），新的类称为子类（派生类）
    - Java只支持单继承，不持多继承
    - 一个类只能有一个父类，但可以有很多子类
    - 从父类继承来的（private）私有东西是没有访问权限的，只有哟个有群，也覆盖不了
- 方法重写
    - 在子类定义一个与父类同名，返回值类型，参数类型均相同的一个方法。方法的重写发生在子父类之间
- 方法重写与重载是区别

比较项目 | 重写| 重载 
---|---|---|---
名称 | override |overload
函数签名 | 方法名，参数列表，返回值均相同 | 方法名相同，参数列表不同，返回值不要求 
发生地方 | 存在继承关系的两个类中 | 同一个类，或者存在继承关系的类中
访问权限 | 子类重写方法的房屋内权限必须大于等于父类的方法 | 没有限制


### 2. implements
- 概念
    - implements关键字是一类实现一个接口用的关键字，它用来实现接口中定义的抽象方法
    - 实现一个接口必须实现接口中的所有方法
    - 使用implements关键字可以变相的使Java具有多继承的特性
- 注意
    - 接口可以被多重实现，抽象类只能被单继承
    - 接口只有定义，抽象类可以有定义和实现
    - 接口的字段默认public static final，抽象类字段默认本包可见
- 作用
    - 可以降低耦合性，也就是说让某个模块或功能能够重复利用
## 四.定义实例及引用实例，判断实例的关键字